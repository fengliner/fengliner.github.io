
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>C++知识点总结 | 琳峰</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="linfeng">
    
    <meta name="description" content="malloc与new的区别：1.new是C++中的操作符，malloc是C中的一个函数2.new不止是分配内存，而且会调用类的构造函数，同时delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数3.内存泄露对于malloc或new都可以">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="琳峰" title="琳峰"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="琳峰">琳峰</a></h1>
				<h2 class="blog-motto">Knowing yourself is the beginning of all wisdom</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:google.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/11/26/c++知识点总结/" title="C++知识点总结" itemprop="url">C++知识点总结</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://google.com" title="linfeng">linfeng</a>
    </p>
  <p class="article-time">
    <time datetime="2014-11-26T13:18:15.000Z" itemprop="datePublished">2014-11-26</time>
    更新日期:<time datetime="2014-11-26T13:41:20.000Z" itemprop="dateModified">2014-11-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc_u4E0Enew_u7684_u533A_u522B_uFF1A"><span class="toc-number">1.</span> <span class="toc-text">malloc与new的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memcpy"><span class="toc-number">2.</span> <span class="toc-text">memcpy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy"><span class="toc-number">3.</span> <span class="toc-text">strcpy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy_u4E0Ememcpy_u7684_u533A_u522B"><span class="toc-number">4.</span> <span class="toc-text">strcpy与memcpy的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">5.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static_u6210_u5458"><span class="toc-number">6.</span> <span class="toc-text">static成员</span></a></li></ol>
		</div>
		
		<h2 id="malloc_u4E0Enew_u7684_u533A_u522B_uFF1A"><a href="#malloc_u4E0Enew_u7684_u533A_u522B_uFF1A" class="headerlink" title="malloc与new的区别："></a>malloc与new的区别：</h2><p>1.new是C++中的操作符，malloc是C中的一个函数<br>2.new不止是分配内存，而且会调用类的构造函数，同时delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free也不会调用析构函数<br>3.内存泄露对于malloc或new都可以检查出来的，区别在于new可以指明是哪个文件的哪一行，而malloc没有这些信息<br>4.new和malloc效率比较：malloc的效率高一点，new可以认为是malloc加构造函数的执行，delete是free加析构函数的执行<br>5.new出来的指针是直接带类型信息的，malloc返回的都是void指针<br>6.new/delete是运算符，malloc/free是函数。运算符只能重载不能自定义；函数的名字随便起，只要是个标识符就行了，但运算符不行，比如，你无法仿照其它语言的特点，自己定义一个乘方运算符“**”，任何函数都可以重载或者覆盖，但通常你不能改变运算符作用于内置类型的行为，比如，你不能通过重载“operator+”，让3+2产生出6来<br>7.malloc与free是C/C++语言的标准库函数，new/delete是C++的运算符，它们都可用于申请动态内存和释放内存<br>8.为什么C++中要存在new/delete，只用malloc/free不就行了吗？<br>对于非内部数据类型(如int，char，float等属于内部数据类型，struct，class等自定义的类型则是非内部类型)光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。<br>因此，C++语言需要一个能完成动态内存分配和初始化工作的运算符new,以及一个能完成清理与释放内存工作的运算符delete</p>
<h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>c和c++使用的内存拷贝函数           </p>
<p>函数原型：<br>void <em>memcpy(void </em>dest,const void *src,size_t n);            </p>
<p>功能：<br>从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中        </p>
<p>所需头文件：<br>c语言中使用#include <string.h> c++中使用#include <cstring>和#include <string.h>都可以    </string.h></cstring></string.h></p>
<p>返回值：<br>函数返回指向dest的指针         </p>
<p>说明：<br>1.source和destin所指的内存区域可以重叠，但是如果source和destin所指的内存区域重叠,那么这个函数并不能确保source所在重叠区域在拷贝之前被覆盖。<br>2.如果目标数组destin本身已有数据，执行memcpy()后，将覆盖原有数据(最多覆盖n)。如果要追加数据，则每次执行memcpy后，要将目标数组地址增加到你要追加数据的地址。<br>注意：source和destin都不一定是数组，任意的可读写的空间均可        </p>
<p>Linux中函数的实现：      </p>
<pre><code>void *memcpy(void *dest,const void *src,size_t count)
{
    assert(dest!=NULL&amp;&amp;src!=NULL);
    char *tmp=dest;
    const char *s=src;
    while(count--)
    {
        *tmp++=*s++;
    }
    return dest;
}       
</code></pre><p>example 1:将s中的字符串复制到字符数组d中          </p>
<pre><code>//memcpy.c
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;
int main()
{
    char *s=&quot;Golden Global View&quot;;
    char d[20];
    memcpy(d,s,(srtlen(s)+1));
    cout&lt;&lt;d&lt;&lt;endl;
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>输出结果： Golden Global View       </p>
<h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h2><p>C语言标准库函数strcpy,把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。     </p>
<p>C语言标准库函数<br>原型声明：extern char <em>strcpy(char </em>dest,const char *src);<br>头文件：#include <string.h><br>功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间<br>说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串，返回指向dest的指针    </string.h></p>
<p>题目：<br>已知strcpy函数的原型是char <em>strcpy(char </em>dest,const char <em>src);<br>1.不调用库函数，实现strcpy函数<br>2.解释为什么要返回char</em>             </p>
<p>1.strcpy的实现代码            </p>
<pre><code>char *strcpy(char *strDest,const char *strSrc)
{
    char *strDestCopy=strDest;
    if((strDest==NULL)||(strSrc==NULL))
        throw &quot;Invalid arguments(s)&quot;;
    while((*strDestCopy++==*strSrc++)!=&apos;\0&apos;);
    return strDest;
}
</code></pre><p>在上面的语句中，循环语句while((<em>strDestCopy++==</em>strSrc++)!=’\0’);较难理解，可以把这句理解为以下操作。<br>第一种：        </p>
<pre><code>while(1)
{
    char temp;
    temp=*strDestCopy=*strSrc;
    strDestCopy++;
    strSrc++;
    if(&apos;\0&apos;==temp)
        break;
}                          
</code></pre><p>第二种：                </p>
<pre><code>while(*strSrc!=&apos;\0&apos;)
{
    *strDestCopy=*strSrc;
    strDestCopy++;
    strSrc++;
}
*strDestCopy=*strSrc;
</code></pre><h2 id="strcpy_u4E0Ememcpy_u7684_u533A_u522B"><a href="#strcpy_u4E0Ememcpy_u7684_u533A_u522B" class="headerlink" title="strcpy与memcpy的区别"></a>strcpy与memcpy的区别</h2><p>前面两篇文章分别介绍了memcpy函数和strcpy函数，两者都可以用来进行字符串的复制。下面我们就看看二者之间的区别。   </p>
<ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整形、结构体、类等。              </li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符“\0”才结束，所以容易溢出。memcpy则是根据其第三个参数决定复制的长度。              </li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy        </li>
</ol>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>一些成员函数改变对象，一些成员函数不改变对象。<br>例如：            </p>
<pre><code>int Point::GetY()
{
   return yVal;
}
</code></pre><p>这个函数被调用时，不改变Point对象，而下面的函数改变Point对象：            </p>
<pre><code>void Point::setPoint(int x,int y)
{
   xVal=x;
   yVal=y;
}
</code></pre><p>为了使成员函数的意义更加清楚，我们可在不改变对象的成员函数的函数原型中加上const说明：          </p>
<pre><code>class Point
{
 public:
   int GetX() const;
   int GetY() const;
   void setPoint(int,int);
  private:
    int xVal,yVal;
};
</code></pre><p>const成员函数应该在函数原型说明和函数定义中都增加const限定：          </p>
<pre><code>int Point::GetY() const
{
   return yVal;
}
class Set
{
 public:
   Set(void){card=0;}
   bool Member(const int) const;
   void AddElem(const int);
   //...
};
bool Set::Member(const int elem) const
{
  //...
}
</code></pre><p>非常量成员函数不能被常量成员对象调用，因为他可能企图修改常量的数据成员：        </p>
<pre><code>const Set s;
s.AddElem(10);  //非法，AddElem不是常量成员函数
s.Member(10);   //正确
</code></pre><p>但构造函数和析构函数对这个规则例外，它们从不定义为常量成员，但可被常量对象调用(被自动调用)。它们也能给常量的数据成员赋值，除非数据成员本身是常量。                          </p>
<p>为什么需要const成员函数？<br>   我们定义的类的成员函数中，常常有一些成员函数不改变类的数据成员，也就是说，这些函数是“只读”函数，而有一些函数要修改类数据成员的值。如果把不改变数据成员的函数都加上const关键字进行标识，显然，可提高程序的可读性。其实，还能提高程序的可靠性，已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理。<br>   为了确保const对象的数据成员不会被改变，在C++中，const对象只能调用const成员函数。如果一个成员函数实际上没有对数据成员作任何形式的修改，但是它没有被const关键字限定，也不能被常量对象调用。<br>const成员函数的使用<br>   const成员函数表示该成员函数只能读类数据成员，而不能修改类成员数据。定义const成员函数时，把const关键字放在函数的参数表和函数体之间。有人可能会问：为什么不将const放在函数声明前呢？因为这样做意味着函数的返回值是常量，意义完全不同。</p>
<p>对象.成员函数<br>   对象  成员函数  对/错                      </p>
<ol>
<li>const   const     对                       </li>
<li>const  no-const   错                        </li>
<li>no-const  const   对                   </li>
<li>no-const no-const 对                 </li>
</ol>
<p>成员函数调用成员函数<br>  成员函数  成员函数  对/错             </p>
<ol>
<li>const     const     对            </li>
<li>const    no-const   错             </li>
<li>no-const  const     对              </li>
<li>no-const  no-const  对            </li>
</ol>
<h2 id="static_u6210_u5458"><a href="#static_u6210_u5458" class="headerlink" title="static成员"></a>static成员</h2><p>在C++中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。      </p>
<p>静态成员的定义或声明要加个关键字static。静态成员可以通过双冒号来使用即&lt;类名&gt;::&lt;静态成员名&gt;。<br>第一个例子，通过类名调用静态成员函数和非静态成员函数              </p>
<pre><code>class Point
{
 public:
   void init() {}
   static void output() {}
};
void main()
{
  Point::init();
  Point::output;
}
</code></pre><p>编译出错：error C2352: ‘Point::init’ : illegal call of non-static member function<br>结论1：不能通过类名来调用类的非静态成员函数         </p>
<p>第二个例子，通过类的对象调用静态成员函数和非静态成员函数，将上例的main()改为：       </p>
<pre><code>void main()
{
  Point pt;
  pt.init();
  pt.output();
}
</code></pre><p>编译通过。<br>结论2：类的对象可以使用静态成员函数和非静态成员函数          </p>
<p>第三个例子，在类的静态成员函数中使用类的非静态成员            </p>
<pre><code>#include &lt;stdio.h&gt;
class Point
{
 public:
   void init() {}
   static void output()
   {
     printf(&quot;%d\n&quot;,m_x);
   }
 private:
   int m_x;
};
void main()
{
  Point pt;
  pt.output();
}
</code></pre><p>编译出错：error C2597: illegal reference to data member ‘Point::m_x’ in a static member function<br>因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员必须在类实例化对象之后才有内存空间，所以这个调用就出错了，就好比没有声明一个变量却提前使用它一样。<br>结论3：静态成员函数中不能引用非静态成员          </p>
<p>第四个例子，在类的非静态成员函数中使用类的静态成员              </p>
<pre><code>class Point  
{  
 public:   
   void init()  
   {    
      output();  
   }  
   static void output() {}  
};  
void main()  
{  
  Point pt;  
  pt.output();  
} 
</code></pre><p>编译通过<br>结论4：类的非静态成员函数可以调用用静态成员函数，但反之不能。        </p>
<p>第五个例子，使用类的静态成员变量            </p>
<pre><code>#include &lt;stdio.h&gt;  
class Point  
{  
 public:   
  Point()  
  {    
    m_nPointCount++;  
  }  
 ~Point()  
 {  
    m_nPointCount--;  
 }  
 static void output()  
 {  
    printf(&quot;%d\n&quot;, m_nPointCount);  
 }  
private:  
 static int m_nPointCount;  
};  
void main()  
{  
  Point pt;  
  pt.output();  
}  
</code></pre><p>按Ctrl+F7编译无错误，按F7生成EXE程序时报链接错误：<br>error LNK2001: unresolved external symbol “private: static int Point::m_nPointCount” (?m_nPointCount@Point@@0HA)<br>这是因为类的静态成员变量在使用前必须先初始化。<br>在main()函数前加上int Point::m_nPointCount = 0;<br>再编译链接无错误，运行程序将输出1。<br>结论5：类的静态成员变量必须先初始化再使用                       </p>
<p>结合上面的五个例子，对类的静态成员变量和成员函数做个总结：                          </p>
<ol>
<li>静态成员函数中不能调用非静态成员                   </li>
<li>非静态成员函数中可以调用静态成员，因为静态成员属于类本身，在类的对象产生之前就已经存在了，所以在非静态成员函数中是可以调用静态成员的                          </li>
<li>静态成员变量使用前必须先初始化，否则会在linker时出错                 </li>
</ol>
<p>再给一个利用类的静态成员变量和函数的例子以加深理解，这个例子建立一个学生类，每个学生类的对象将组成一个双向链表，用一个静态成员变量记录这个双向链表的表头，一个静态成员函数输出这个双向链表。            </p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
const int MAX_NAME_SIZE = 30;
class Student
{
 public:
   Student(char *pszName);
   ~Student();
 public:
   static void PrintfAllStudents();
 private:
   char m_name[MAX_NAME_SIZE];
   Student *next;
   Student *prev;
   static Student *m_head;
};
Student::Student(char *pszName)
{
  strcpy(this-&gt;m_name,pszName);
  //建立双向链表，新数据从链表头部插入
  this-&gt;next=m_head;
  this-&gt;prev=NULL;
  if(m_head!=NULL)
  {
    m_head-&gt;prev=this;
  }
  m_head=this;
}
Student::~Student()      //析构过程就是节点的脱离过程
{
  if(this==m_head)
  {
    m_head=this-&gt;next;
  }
  else
  {
    this-&gt;prev-&gt;next=this-&gt;next;
    this-&gt;next-&gt;prev=this-&gt;prev;
  }
}
void Student::PrintfAllStudents()
{
  for(Student *p=m_head;p!=NULL;p=p-&gt;next)
  {
    printf(&quot;%s\n&quot;,p-&gt;m_name);
  }
}
Student* Student::m_head=NULL;
void main()
{
  Student studentA(&quot;AAA&quot;);
  Student studentB(&quot;BBB&quot;);
  Student studentC(&quot;CCC&quot;); 
  Student studentD(&quot;DDD&quot;);
  Student student(&quot;MoreFree&quot;);
  Student::PrintfAllStudents();
}
</code></pre><p>程序将输出：<br><img src="/img/img002.jpg" alt="图片"><br>当然在本例还可以增加个静态成员变量来表示链表中学生个数，如果读者有兴趣，就将这个作为小练习吧。             </p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C++</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/learning/">learning</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://google.com/2014/11/26/c++知识点总结/" data-title="C++知识点总结 | 琳峰" data-tsina="只要-心-够决" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2014/12/12/javascript中的call,apply和bind/" title="JavaScript中的call,apply和bind">
  <strong>PREVIOUS:</strong><br/>
  <span>
  JavaScript中的call,apply和bind</span>
</a>
</div>


<div class="next">
<a href="/2014/11/20/node.js后台运行/"  title="node.js后台运行">
 <strong>NEXT:</strong><br/> 
 <span>node.js后台运行
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc_u4E0Enew_u7684_u533A_u522B_uFF1A"><span class="toc-number">1.</span> <span class="toc-text">malloc与new的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memcpy"><span class="toc-number">2.</span> <span class="toc-text">memcpy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy"><span class="toc-number">3.</span> <span class="toc-text">strcpy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy_u4E0Ememcpy_u7684_u533A_u522B"><span class="toc-number">4.</span> <span class="toc-text">strcpy与memcpy的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">5.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static_u6210_u5458"><span class="toc-number">6.</span> <span class="toc-text">static成员</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/basketball/" title="basketball">basketball<sup>4</sup></a></li>
		
			<li><a href="/categories/learning/" title="learning">learning<sup>32</sup></a></li>
		
			<li><a href="/categories/life/" title="life">life<sup>3</sup></a></li>
		
			<li><a href="/categories/为你读诗/" title="为你读诗">为你读诗<sup>2</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/C/" title="C++">C++<sup>6</sup></a></li>
		
			<li><a href="/tags/Mongodb/" title="Mongodb">Mongodb<sup>3</sup></a></li>
		
			<li><a href="/tags/Ubuntu/" title="Ubuntu">Ubuntu<sup>2</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/http/" title="http">http<sup>1</sup></a></li>
		
			<li><a href="/tags/ios/" title="ios">ios<sup>1</sup></a></li>
		
			<li><a href="/tags/markdown/" title="markdown">markdown<sup>1</sup></a></li>
		
			<li><a href="/tags/node-js/" title="node.js">node.js<sup>9</sup></a></li>
		
			<li><a href="/tags/web/" title="web">web<sup>2</sup></a></li>
		
			<li><a href="/tags/数据库/" title="数据库">数据库<sup>1</sup></a></li>
		
			<li><a href="/tags/数据结构/" title="数据结构">数据结构<sup>5</sup></a></li>
		
			<li><a href="/tags/文件操作/" title="文件操作">文件操作<sup>1</sup></a></li>
		
			<li><a href="/tags/篮球/" title="篮球">篮球<sup>4</sup></a></li>
		
			<li><a href="/tags/虚函数/" title="虚函数">虚函数<sup>1</sup></a></li>
		
			<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
		
			<li><a href="/tags/诗歌/" title="诗歌">诗歌<sup>2</sup></a></li>
		
			<li><a href="/tags/随笔/" title="随笔">随笔<sup>3</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hi,I&#39;m linfeng.For now I&#39;m a student at college. <br/>
			Node.js is my interest now which I&#39;d like to share with you at this blog.</p>
	</section>
	 
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/2088462463" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/fengliner" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://google.com" target="_blank" title="linfeng">linfeng</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"null"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
